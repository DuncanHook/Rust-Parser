use std::env;
use std::fs::File;
use std::io::prelude::*;
use regex::Regex;
use std::path::Path; 
use std::process;  

fn main() -> std::io::Result<()>{
    //Looks at parameters provided.
    let args: Vec<String> = env::args().collect();

    //Validates the proper number of parameters have been provided.
    if args.len() == 3 {
        println!("processing input file {}", &args[1]);

        //validates the file  provided exists. exits program if it doesnt. 
        if Path::new(&args[1]).exists() == false{
            println!("File does not exist, please provide valid file.");
            process::exit(1);
        }
        
        //ensures proper flag was given. Exits program if it wasnt
        if &args[2] != "-p" && &args[2] != "-s"{
            println!("Improper flag given, please ensure you use -s or -p.");
            process::exit(1);
        }

        let mut file = File::open(&args[1])?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        
        //set up Lexical and Syntax Analysis
        let myregex = r"^((\s*[a-z]+\s*=\s*point\s*\(\s*\d+\s*,\s*\d+\s*\)\s*;\n*){2}\s*[a-z]+\s*=\s*point\s*\(\s*\d+\s*,\s*\d+\s*\)\s*.\n*)$";
        let re = Regex::new(myregex).unwrap();
        if re.is_match(&contents) {
            println!("Lexical and Syntax analysis passed");


            /***********************************************************************
            *This section generates a vector called "tokens". tokens               *
            *contains all of the tokens (and associated lexemes)                   *
            *generated by the sentence contained within the given file.            *
            *it does this by breaking the contents of the file into a char vector, * 
            *and then iterating through that vector.                               *
            ************************************************************************/
            let char_vec: Vec<char> = contents.chars().collect();

            let mut tokens: Vec<String> = vec![];
            let mut start_index = 0;
            let mut end_index = 0;
            let mut current_type = "";

            for c in &char_vec {

                //move index along for letters and insert POINT into tokens
                if c.is_alphabetic(){
                    if current_type == "assign" && &c.to_string() == "p"{
                        current_type = "letter";
                        let new_entry = "POINT".to_string();
                        tokens.push(new_entry);
                    }
                    else if current_type != "letter"{ 
                        current_type = "letter";
                        start_index = end_index;
                    }//end type switch to letter

                    end_index += 1;
                    
                } //end alphabetical entry

                //move index along for numbers
                else if c.is_numeric(){
                    if current_type != "digit"{
                        current_type = "digit";
                        start_index =  end_index;
                    }//end type switch to NUM
                    end_index += 1;
                }//end numeric entry

                else{
                    let current_char = &c.to_string();
                    if current_char == "="{
                        let mut new_entry = "ID ".to_string();
                        while start_index < end_index{
                            new_entry.push_str(&char_vec[start_index].to_string());
                            start_index += 1;
                        }
                        //insert ID into tokens
                        tokens.push(new_entry);
                        

                        //insert ASSIGN into tokens
                        current_type = "assign";
                        new_entry = "ASSIGN".to_string();
                        tokens.push(new_entry);
                        end_index += 1;
                    }//end ASSIGN entry

                    //LPAREN into tokens
                    else if current_char == "("{
                        let new_entry = "LPAREN".to_string();
                        tokens.push(new_entry);
                        end_index += 1;
                    }//end LPAREN

                    //1st NUM into tokens
                    else if current_char == ","{
                        let mut new_entry = "NUM ".to_string();
                        while start_index < end_index{
                            new_entry.push_str(&char_vec[start_index].to_string());
                            start_index += 1;
                        }
                        tokens.push(new_entry);

                        //COMMA into tokens
                        current_type = "COMMA";
                        let new_entry = "COMMA".to_string();
                        tokens.push(new_entry);
                        end_index += 1;
                    }//end COMMA

                    //2nd Num into tokens
                    else if current_char == ")"{
                        let mut new_entry = "NUM ".to_string();
                        while start_index < end_index{
                            new_entry.push_str(&char_vec[start_index].to_string());
                            start_index += 1;
                        }
                        tokens.push(new_entry);

                        //RPAREN into tokens
                        let new_entry = "RPAREN".to_string();
                        tokens.push(new_entry);
                        end_index += 1;
                    }//end LPAREN

                    //semicolon to tokens
                    else if current_char == ";"{
                      let new_entry = "SEMICOLON".to_string();
                      tokens.push(new_entry);
                      end_index += 1;
                    }//end SEMICOLON

                    //period into tokens
                    else if current_char == "."{
                       let new_entry = "PERIOD".to_string();
                       tokens.push(new_entry);
                    }//end PERIOD

                    //move index for whitesapce
                    else{
                        end_index += 1;
                    }//end whitespace
                }//end character entry 
            } // end character iterator
            

            /********************************************************
            * This next section sets up the pairs of numbers given  *
            * by the earlier file to be output in the proper format *
            * for either scheme or prolog. This is done by taking   *
            * the associated entry of the token vector and taking   *
            * the lexemes out to store in a variable named          *
            * pair1/2/3 depending on which pair is being generated. *
            *********************************************************/

            //set up first pair variables
            let mut pair1 = String::new();
            let pair1_1_vec: Vec<char> = tokens[4].chars().collect();
            let pair1_2_vec: Vec<char> = tokens[6].chars().collect();

            //set up second pair variables
            let mut pair2 = String::new();
            let pair2_1_vec: Vec<char> = tokens[13].chars().collect();
            let pair2_2_vec: Vec<char> = tokens[15].chars().collect();

            //set up third pair variables
            let mut pair3 = String::new();
            let pair3_1_vec: Vec<char> = tokens[22].chars().collect();
            let pair3_2_vec: Vec<char> = tokens[24].chars().collect();


            /***********************************************************
            * The scheme output section formats the pairs to look like *
            * "NUM1 NUM2)" in order to be in the proper output format  * 
            ************************************************************/

            //scheme output
            if args[2] == "-s"{

                //first pair
                end_index = 0;
                current_type = "";
                for c in &pair1_1_vec {
                    if c.is_numeric(){
                        if current_type != "number"{
                            current_type ="number";
                            start_index = end_index;
                        }//end if
                    }
                end_index += 1;
                }
                while start_index < end_index {
                    pair1.push_str(&pair1_1_vec[start_index].to_string());
                    start_index += 1;
                }
                pair1.push_str(" ");

                end_index = 0;
                current_type = "";
                for c in &pair1_2_vec {
                    if c.is_numeric(){
                        if current_type != "number"{
                            current_type ="number";
                            start_index = end_index;
                        }//end if
                    }
                end_index += 1;
                }
                while start_index < end_index {
                    pair1.push_str(&pair1_2_vec[start_index].to_string());
                    start_index += 1;
                }
                pair1.push_str(")");
                //end first pair

                //second pair
                end_index = 0;
                current_type = "";
                for c in &pair2_1_vec {
                    if c.is_numeric(){
                        if current_type != "number"{
                            current_type ="number";
                            start_index = end_index;
                        }//end if
                    }
                    end_index += 1;
                }
             while start_index < end_index {
                    pair2.push_str(&pair2_1_vec[start_index].to_string());
                    start_index += 1;
                }
                pair2.push_str(" ");
 
                end_index = 0;
                current_type = "";
                for c in &pair2_2_vec {
                    if c.is_numeric(){
                        if current_type != "number"{
                            current_type ="number";
                            start_index = end_index;
                        }//end if
                    }
                    end_index += 1;
                }
                while start_index < end_index {
                    pair2.push_str(&pair2_2_vec[start_index].to_string());
                    start_index += 1;
                }
                pair2.push_str(")");
                //end second pair

              //third pair
              end_index = 0;
              current_type = "";
              for c in &pair3_1_vec {
                if c.is_numeric(){
                    if current_type != "number"{
                        current_type ="number";
                        start_index = end_index;
                    }//end if
                }
                end_index += 1;
              }
              while start_index < end_index {
                pair3.push_str(&pair3_1_vec[start_index].to_string());
                start_index += 1;
              }
              pair3.push_str(" ");
  
              end_index = 0;
              current_type = "";
                for c in &pair3_2_vec {
                    if c.is_numeric(){
                        if current_type != "number"{
                            current_type ="number";
                            start_index = end_index;
                        }//end if
                    }
                    end_index += 1;
                }
              while start_index < end_index {
                  pair3.push_str(&pair3_2_vec[start_index].to_string());
                  start_index += 1;
                }
              pair3.push_str(")");
              //end third pair

              //output
              println!("(calulate-triangle (make-point {} (make-point {} (make-point {})", &pair1, &pair2, &pair3);
            } //end scheme output
    


            /******************************************************
            * The prolog output section formats the number pairs  *
            * to look like "(NUM1,NUM2)", ensuring the output     *
            * is in the proper format for Prolog.                 *
            *******************************************************/

            //Prolog output
            else if args[2] == "-p"{

                   //first pair
                pair1.push_str("(");
                end_index = 0;
                current_type = "";
                for c in &pair1_1_vec {
                    if c.is_numeric(){
                        if current_type != "number"{
                            current_type ="number";
                            start_index = end_index;
                        }//end if
                    }//end for  
                    end_index += 1;
                }//end if
                while start_index < end_index {
                    pair1.push_str(&pair1_1_vec[start_index].to_string());
                    start_index += 1;
                }//end while
                pair1.push_str(",");

                end_index = 0;
                current_type = "";
                for c in &pair1_2_vec {
                    if c.is_numeric(){
                        if current_type != "number"{
                            current_type ="number";
                            start_index = end_index;
                        }//end if
                    }//end if
                    end_index += 1;
                }//end for
                while start_index < end_index {
                    pair1.push_str(&pair1_2_vec[start_index].to_string());
                    start_index += 1;
                }//end while
                pair1.push_str(")");
                //end first pair

                //second pair
                pair2.push_str("(");
                end_index = 0;
                current_type = "";
                for c in &pair2_1_vec {
                     if c.is_numeric(){
                        if current_type != "number"{
                            current_type ="number";
                            start_index = end_index;
                        }//end if
                    }//end if
                    end_index += 1;
                }//end for
                while start_index < end_index {
                     pair2.push_str(&pair2_1_vec[start_index].to_string());
                    start_index += 1;
                }//end while
                pair2.push_str(",");
 
                end_index = 0;
                current_type = "";
                for c in &pair2_2_vec {
                    if c.is_numeric(){
                        if current_type != "number"{
                            current_type ="number";
                            start_index = end_index;
                        }//end if
                    }//end if
                    end_index += 1;
                }//end for
                while start_index < end_index {
                    pair2.push_str(&pair2_2_vec[start_index].to_string());
                    start_index += 1;
                }//end while
                pair2.push_str(")");
                //end second pair

                //third pair
                pair3.push_str("(");
                end_index = 0;
                current_type = "";
                for c in &pair3_1_vec {
                    if c.is_numeric(){
                        if current_type != "number"{
                            current_type ="number";
                            start_index = end_index;
                        }//end if
                    }//end if
                    end_index += 1;
                }//end for
                while start_index < end_index {
                    pair3.push_str(&pair3_1_vec[start_index].to_string());
                    start_index += 1;
                }//end while
                pair3.push_str(", ");
  
                end_index = 0;
                current_type = "";
                for c in &pair3_2_vec {
                    if c.is_numeric(){
                        if current_type != "number"{
                            current_type ="number";
                            start_index = end_index;
                        }//end if
                    }//end if
                    end_index += 1;
                }//end for
                while start_index < end_index {
                    pair3.push_str(&pair3_2_vec[start_index].to_string());
                    start_index += 1;
                }//end while
                pair3.push_str(")");
                //end third pair

                //prolog output
                println!("query(line(point2d{}, point2d{}, point2d{}))", &pair1, &pair2, &pair3);
                println!("query(triangle(point2d{}, point2d{}, point2d{}))", &pair1, &pair2, &pair3);
                println!("query(vertical(point2d{}, point2d{}, point2d{}))", &pair1, &pair2, &pair3);
                println!("query(horizontal(point2d{}, point2d{}, point2d{}))", &pair1, &pair2, &pair3);
                println!("query(equilateral(point2d{}, point2d{}, point2d{}))", &pair1, &pair2, &pair3);
                println!("query(isosceles(point2d{}, point2d{}, point2d{}))", &pair1, &pair2, &pair3);
                println!("query(right(point2d{}, point2d{}, point2d{}))", &pair1, &pair2, &pair3);
                println!("query(scalene(point2d{}, point2d{}, point2d{}))", &pair1, &pair2, &pair3);
                println!("query(acute(point2d{}, point2d{}, point2d{}))", &pair1, &pair2, &pair3);
                println!("query(obtuse(point2d{}, point2d{}, point2d{}))", &pair1, &pair2, &pair3);
                println!("writeln(T) :- write(T), nl.");
                println!("main:- forall(query(Q), Q-> writeln('yes')) ; writeln('no'))),\n\thalt.");
            }//end prolog output
        }//end output generation

        //if the lexical analysis fails it informs the user then exits the program
        else {
            println!("Lexical and Syntax analysis failed.")
        }//end lexical fail
    }
    //if there aren't enough parameters given then the program informs the user and exits.
    else {
        println!("Invalid amount of parameters.");
    }//end param error    
    Ok(())
}// end main